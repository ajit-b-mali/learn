# Two Pointers

- Used to turn a nested loop into a single loop i.e. O(n^2) to O(n)

1. **Initialization**: Start with two pointers, usually at the beginning and end of the data structure or both at same end.
2. **Movement**: Move the pointers towards each other or in the same direction based on certain conditions until they meet, cross or go out of border.
3. **Conditions**: The movement of the pointers is typically based on specific conditions related to the problem being solved.

## 1. Two Sum (!!! can be solved using HashMap !!!)

- iterate over all pairs using two pointers

```c++
for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
        // you got unique pair(i, j)
    }
}
```

- remember the value and index using HashMap

```c++
unordered_map<int, int> map; // value -> index
for (int i = 0; i < n; i++) {
    int complement = target - nums[i];
    if (map.find(complement) != map.end()) {
        return {map[complement], i};
    }
    map[nums[i]] = i;
}
```

- The strategy is to trade a bit of memory (space) for speed. We iterate through the array once, and for every number we visit, we ask the map: "Have I seen your partner yet?"

## 2. Remove Duplicates from Sorted Array

- use two pointers to overwrite duplicates

```c++

```

- `readIndex` goes through each element, while `writeIndex` only moves when a new unique element is found. This way, we overwrite duplicates in place.
